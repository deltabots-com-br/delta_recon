<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DELTA SOLDIER OS v2.2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src='https://unpkg.com/tesseract.js@v2.1.0/dist/tesseract.min.js'></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body {
            background-color: #000;
            color: #0f0;
            font-family: 'Share Tech Mono', monospace;
            overflow: hidden;
            touch-action: none;
        }

        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(0, 255, 0, 0.3);
            animation: scan 3s linear infinite;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes scan {
            0% {
                top: 0%;
            }

            100% {
                top: 100%;
            }
        }

        .hud-panel {
            background: rgba(0, 20, 0, 0.6);
            border: 1px solid #004400;
            backdrop-filter: blur(2px);
        }

        .blinking {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        #video {
            transform: scaleX(1);
            /* Espelhar se for selfie, mas traseira nao */
        }
    </style>
</head>

<body class="h-screen w-screen flex flex-col relative">

    <!-- VIDEO LAYER -->
    <video id="video" class="absolute top-0 left-0 w-full h-full object-cover z-0" autoplay playsinline muted></video>
    <canvas id="outputCanvas" class="absolute top-0 left-0 w-full h-full z-10"></canvas>
    <div class="scan-line"></div>

    <!-- UI LAYER -->
    <div id="ui-layer"
        class="absolute top-0 left-0 w-full h-full z-20 flex flex-col justify-between p-2 pointer-events-none">

        <!-- TOP HUD -->
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="hud-panel p-2 text-xs">
                <div class="text-green-500 font-bold">UNIT ID: <span id="hud-unit-id"
                        class="text-white">INITIALIZING...</span></div>
                <div class="text-green-700">OP: <span class="text-green-400">ACTIVE</span></div>
                <div class="mt-1 text-[10px] text-gray-400">
                    GPS: <span id="gps-lat">--.----</span>, <span id="gps-lon">--.----</span>
                </div>
            </div>
            <div class="hud-panel p-2 text-xs text-right">
                <div class="text-green-500 font-bold">SYS STATUS</div>
                <div id="log-tf" class="text-gray-500">AI CORE: <span class="text-yellow-500">INIT</span></div>
                <div id="log-obj" class="text-gray-500">VISUAL: <span class="text-yellow-500">WAIT</span></div>
                <div id="log-pose" class="text-gray-500">POSE: <span class="text-yellow-500">WAIT</span></div>
                <div id="log-ocr" class="text-gray-500">INTEL: <span class="text-yellow-500">WAIT</span></div>
                <div id="log-gps" class="text-gray-500">GPS: <span class="text-yellow-500">WAIT</span></div>
            </div>
        </div>

        <!-- CENTER RETICLE (CSS) -->
        <div
            class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-64 h-64 border border-green-900/50 rounded-full flex items-center justify-center pointer-events-none opacity-50">
            <div class="w-1 h-1 bg-green-500 rounded-full"></div>
            <div class="absolute top-0 left-1/2 -translate-x-1/2 w-0.5 h-4 bg-green-500"></div>
            <div class="absolute bottom-0 left-1/2 -translate-x-1/2 w-0.5 h-4 bg-green-500"></div>
            <div class="absolute left-0 top-1/2 -translate-y-1/2 w-4 h-0.5 bg-green-500"></div>
            <div class="absolute right-0 top-1/2 -translate-y-1/2 w-4 h-0.5 bg-green-500"></div>
        </div>

        <!-- THREAT ALERT -->
        <div id="threat-container" class="hidden">
            <div id="threat-level" class="text-xs font-bold tracking-[0.5em] uppercase text-green-500">SECTOR CLEAR
            </div>
        </div>

        <!-- BOTTOM CONTROLS -->
        <div class="controls pointer-events-auto mb-4">
            <div class="flex gap-2 mb-2">
                <button id="mode-btn" onclick="toggleMode()"
                    class="flex-1 border border-green-500 bg-green-900/40 text-xs py-3 text-white font-bold hover:bg-green-500 hover:text-black transition-all">MODE:
                    OPTICAL</button>
                <button id="ocr-btn" onclick="triggerOCR()"
                    class="flex-1 border border-green-500 bg-green-900/40 text-xs py-3 text-white font-bold hover:bg-green-500 hover:text-black transition-all">SCAN
                    INTEL</button>
            </div>
            <div class="flex gap-2">
                <div class="flex-1 hud-panel p-1 flex items-center justify-center">
                    <input type="range" id="gain-slider" min="1" max="5" step="0.1" value="1"
                        class="w-full accent-green-500">
                </div>
            </div>

            <!-- OCR RESULT POPUP -->
            <div id="ocr-result"
                class="hidden mt-2 p-2 bg-green-900/80 border border-green-400 text-white text-xs font-mono break-all">
                <span class="text-green-300 font-bold">INTEL ACQUIRED:</span> <span id="ocr-text">...</span>
            </div>
        </div>
    </div>

    <!-- START OVERLAY -->
    <div id="loading"
        class="absolute top-0 left-0 w-full h-full bg-black z-50 flex flex-col items-center justify-center p-8">
        <div class="text-green-500 font-bold text-2xl mb-4 tracking-widest">DELTA OS</div>
        <div class="text-green-800 text-xs mb-8 font-mono">TACTICAL SYSTEMS INITIALIZATION</div>
        <div id="boot-log" class="text-green-900 text-[10px] font-mono h-32 overflow-hidden mb-4 w-full text-center">
        </div>
        <button id="start-btn" onclick="engageSystems()" disabled
            class="border border-green-900 bg-green-900/20 text-green-700 px-8 py-4 font-bold tracking-widest transition-all">INITIALIZING...</button>
        <div id="error-msg" class="text-red-500 text-xs mt-4 hidden text-center"></div>
    </div>

    <!-- PIP HQ VIDEO -->
    <div id="hq-pip" class="absolute top-14 right-2 w-32 h-24 bg-black border border-green-500 z-30 hidden">
        <div class="absolute top-0 left-0 bg-green-900/80 text-[8px] text-white px-1">HQ FEED</div>
        <div id="hq-voice-indicator"
            class="absolute bottom-0 right-0 w-2 h-2 bg-green-500 rounded-full m-1 hidden blinking"></div>
    </div>

    <script>
        // --- CONFIG & STATE ---
        const config = { mode: 'optical', gain: 1.0 };
        const video = document.getElementById('video');
        const canvas = document.getElementById('outputCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('start-btn');
        const errorMsg = document.getElementById('error-msg');
        const hqPip = document.getElementById('hq-pip');

        let objectDetector = null;
        let poseDetector = null;
        let ocrWorker = null;
        let currentGPS = { lat: 0, lon: 0 };
        let currentBattery = "100%";
        let currentThreatStatus = "CLEAR";

        // Paths for icons
        const humanPath = new Path2D("M10 0a4 4 0 110 8 4 4 0 010-8zm0 10c-2.67 0-8 1.34-8 4v6h16v-6c0-2.66-5.33-4-8-4z");
        const knifePath = new Path2D("M15.5 2.5l-5 5-2.5-2.5 5-5zm-6 6l-6 6-2.5 6 6-2.5 6-6z");

        function setLog(id, status, type) {
            const el = document.getElementById(id);
            let color = type === 'ok' ? 'text-green-500' : (type === 'wait' ? 'text-yellow-500' : 'text-red-500');
            el.innerHTML = `${el.innerText.split(':')[0]}: <span class="${color}">${status}</span>`;
        }

        // --- BATTERY API ---
        async function initBattery() {
            try {
                const bat = await navigator.getBattery();
                const updateBat = () => { currentBattery = Math.round(bat.level * 100) + '%' + (bat.charging ? ' (CHG)' : ''); };
                updateBat();
                bat.addEventListener('levelchange', updateBat);
                bat.addEventListener('chargingchange', updateBat);
            } catch (e) {
                setInterval(() => {
                    let lvl = parseInt(currentBattery) || 100;
                    if (Math.random() > 0.9 && lvl > 0) lvl--;
                    currentBattery = lvl + '%';
                }, 60000);
            }
        }

        function startTelemetryLoop() {
            setInterval(() => {
                if (dataConn && dataConn.open) broadcastTelemetry();
            }, 1000);
        }

        async function bootSequence() {
            // Timeout de seguran√ßa para liberar o bot√£o mesmo se a IA falhar
            setTimeout(() => {
                if (startBtn.disabled) {
                    console.warn("Force enabling start button due to timeout");
                    enableStart();
                }
            }, 3000);

            try { await tf.ready(); setLog('log-tf', 'OK', 'ok'); } catch (e) { setLog('log-tf', 'FAIL', 'fail'); }
            try { objectDetector = await cocoSsd.load({ base: 'lite_mobilenet_v2' }); setLog('log-obj', 'OK', 'ok'); } catch (e) { setLog('log-obj', 'SKIP', 'wait'); }
            try { poseDetector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }); setLog('log-pose', 'OK', 'ok'); } catch (e) { setLog('log-pose', 'SKIP', 'wait'); }
            try { ocrWorker = Tesseract.createWorker(); await ocrWorker.load(); await ocrWorker.loadLanguage('eng'); await ocrWorker.initialize('eng'); setLog('log-ocr', 'OK', 'ok'); } catch (e) { setLog('log-ocr', 'SKIP', 'wait'); }

            initBattery();
            setLog('log-gps', 'READY', 'ok');
            enableStart();
        }

        function enableStart() {
            startBtn.disabled = false;
            startBtn.innerText = "ENGAGE SENSORS";
            startBtn.classList.remove('bg-green-900/20', 'border-green-900', 'text-green-700');
            startBtn.classList.add('bg-green-900/50', 'border-green-500', 'text-green-500');
        }

        function broadcastTelemetry() {
            const payload = {
                gps: currentGPS,
                threat: currentThreatStatus,
                visionMode: config.mode.toUpperCase(),
                battery: currentBattery
            };
            if (dataConn && dataConn.open) dataConn.send({ type: 'TELEMETRY', payload: payload });
        }

        async function aiLoop() {
            if (video.paused) { setTimeout(aiLoop, 500); return; }
            try {
                let detectedObjects = [];
                if (objectDetector) detectedObjects = await objectDetector.detect(video);

                let detectedPoses = [];
                if (poseDetector) detectedPoses = await poseDetector.estimatePoses(video);

                evaluateThreat(detectedObjects, detectedPoses);
                window.lastPredictions = detectedObjects;
                window.lastPoses = detectedPoses;
            } catch (e) { }
            setTimeout(aiLoop, 150);
        }

        function evaluateThreat(objects, poses) {
            let status = "SECTOR CLEAR";
            let className = "text-green-500";
            let containerClass = "bg-black/60 border-green-900";
            const WEAPONS = ['knife', 'scissors', 'baseball bat'];
            const hasWeapon = objects.some(o => WEAPONS.includes(o.class));
            const hasHuman = objects.some(o => o.class === 'person');
            let isSurrender = false;

            if (hasHuman && poses.length > 0) {
                const p = poses[0];
                const nose = p.keypoints.find(k => k.name === 'nose');
                const lW = p.keypoints.find(k => k.name === 'left_wrist');
                const rW = p.keypoints.find(k => k.name === 'right_wrist');
                if (nose && lW && rW && lW.score > 0.3 && rW.score > 0.3 && lW.y < nose.y && rW.y < nose.y) isSurrender = true;
            }

            if (hasWeapon) { status = "‚ö† LETHAL THREAT ‚ö†"; className = "text-red-500 threat-lethal"; containerClass = "bg-red-900/30 border-red-500"; }
            else if (isSurrender) { status = "SURRENDER CONFIRMED"; className = "text-cyan-400 threat-surrender"; containerClass = "bg-cyan-900/30 border-cyan-500"; }
            else if (hasHuman) { status = "CONTACT"; className = "text-orange-500 threat-contact"; containerClass = "bg-yellow-900/30 border-orange-500"; }

            const threatLevel = document.getElementById('threat-level');
            if (threatLevel) {
                threatLevel.innerText = status;
                threatLevel.className = "text-xs font-bold tracking-[0.5em] uppercase " + className;
            }
            const threatContainer = document.getElementById('threat-container');
            if (threatContainer) {
                threatContainer.className = "w-full flex justify-center items-center overflow-hidden h-8 backdrop-blur border-y transition-all duration-200 " + containerClass;
            }

            currentThreatStatus = status;
        }

        function renderLoop() {
            if (video.readyState >= 2) {
                const w = canvas.width, h = canvas.height;
                ctx.drawImage(video, 0, 0, w, h);
                const d = ctx.getImageData(0, 0, w, h).data;
                if (config.mode === 'nvg') {
                    for (let i = 0; i < d.length; i += 4) {
                        let l = (d[i] * 0.3 + d[i + 1] * 0.59 + d[i + 2] * 0.11) * config.gain;
                        d[i] = 0; d[i + 1] = l > 255 ? 255 : l; d[i + 2] = 0;
                    }
                }
                ctx.putImageData(new ImageData(d, w, h), 0, 0);
                if (window.lastPredictions) {
                    const sx = w / video.videoWidth, sy = h / video.videoHeight;
                    ctx.lineWidth = 2; ctx.font = "10px monospace";
                    window.lastPredictions.forEach(obj => {
                        const isWeap = ['knife', 'scissors', 'baseball bat'].includes(obj.class);
                        const color = isWeap ? '#f00' : (obj.class === 'person' ? 'orange' : '#0f0');
                        const x = obj.bbox[0] * sx, y = obj.bbox[1] * sy, bw = obj.bbox[2] * sx, bh = obj.bbox[3] * sy;
                        const L = 15;
                        ctx.strokeStyle = color; ctx.fillStyle = color;
                        ctx.beginPath(); ctx.moveTo(x, y + L); ctx.lineTo(x, y); ctx.lineTo(x + L, y); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(x + bw - L, y); ctx.lineTo(x + bw, y); ctx.lineTo(x + bw, y + L); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(x, y + bh - L); ctx.lineTo(x, y + bh); ctx.lineTo(x + L, y + bh); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(x + bw - L, y + bh); ctx.lineTo(x + bw, y + bh); ctx.lineTo(x + bw, y + bh - L); ctx.stroke();
                        ctx.fillText(isWeap ? "WEAPON" : obj.class.toUpperCase(), x + 5, y - 5);
                        if (obj.class === 'person') { ctx.save(); ctx.translate(x - 15, y); ctx.scale(0.8, 0.8); ctx.fill(humanPath); ctx.restore(); }
                        if (isWeap) { ctx.save(); ctx.translate(x - 15, y); ctx.scale(0.8, 0.8); ctx.fill(knifePath); ctx.restore(); }
                    });
                }
            }
            requestAnimationFrame(renderLoop);
        }

        function initGPS() {
            if (navigator.geolocation) navigator.geolocation.watchPosition(pos => {
                currentGPS.lat = pos.coords.latitude;
                currentGPS.lon = pos.coords.longitude;
                document.getElementById('gps-lat').innerText = pos.coords.latitude.toFixed(5);
                document.getElementById('gps-lon').innerText = pos.coords.longitude.toFixed(5);
            });
        }

        async function triggerOCR() {
            if (!ocrWorker) return;
            document.getElementById('ocr-btn').innerText = "SCANNING...";
            const tmp = document.createElement('canvas');
            tmp.width = video.videoWidth / 2; tmp.height = video.videoHeight / 4;
            tmp.getContext('2d').drawImage(video, video.videoWidth / 4, video.videoHeight / 2 - video.videoHeight / 8, video.videoWidth / 2, video.videoHeight / 4, 0, 0, tmp.width, tmp.height);
            try {
                const { data: { text } } = await ocrWorker.recognize(tmp);
                const clean = text.replace(/\n/g, " ").trim().substring(0, 30);
                if (clean.length > 2) {
                    document.getElementById('ocr-text').innerText = clean;
                    document.getElementById('ocr-result').style.display = 'block';
                    setTimeout(() => document.getElementById('ocr-result').style.display = 'none', 5000);
                    if (dataConn && dataConn.open) dataConn.send({ type: 'INTEL_DATA', payload: { text: clean } });
                }
            } catch (e) { }
            document.getElementById('ocr-btn').innerText = "SCAN INTEL";
        }

        function toggleMode() {
            const btn = document.getElementById('mode-btn');
            if (config.mode === 'nvg') { config.mode = 'optical'; btn.innerText = "MODE: OPTICAL"; btn.classList.replace('text-green-400', 'text-white'); }
            else { config.mode = 'nvg'; btn.innerText = "MODE: NVG"; btn.classList.replace('text-white', 'text-green-400'); }
        }

        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resizeCanvas);
        document.getElementById('gain-slider').addEventListener('input', e => config.gain = parseFloat(e.target.value));

        let peer = null, dataConn = null, localStream = null;
        const myPeerId = "OP-" + Math.floor(Math.random() * 900 + 100);
        window.myPeerId = myPeerId;

        const hudId = document.getElementById('hud-unit-id');
        if (hudId) hudId.innerText = myPeerId;

        function initNetworkID() {
            console.log('üåê Inicializando rede com ID:', myPeerId);
            if (hudId) hudId.innerText = myPeerId + " (CONNECTING...)";

            try {
                peer = new Peer(myPeerId);
            } catch (e) {
                console.error("PeerJS Init Failed:", e);
                if (window.deltaUI) deltaUI.showNotification("NET INIT FAIL", "error");
                return;
            }

            peer.on('open', () => {
                console.log('‚úÖ Rede PeerJS conectada');
                if (hudId) {
                    hudId.innerText = myPeerId + " [ONLINE]";
                    hudId.style.color = "#0f0";
                    hudId.style.textShadow = "0 0 10px #0f0";
                }
                startTelemetryLoop();
                if (window.deltaUI) deltaUI.showNotification("NETWORK ONLINE", "success");
            });

            peer.on('error', (err) => {
                console.error('‚ùå Erro PeerJS:', err);
                if (window.deltaUI) deltaUI.showNotification("NET ERROR: " + err.type, "error");
            });

            peer.on('disconnected', () => {
                console.warn('‚ö†Ô∏è PeerJS desconectado. Tentando reconectar...');
                if (hudId) {
                    hudId.innerText = myPeerId + " [OFFLINE]";
                    hudId.style.color = "#f00";
                }
                peer.reconnect();
            });

            peer.on('connection', (conn) => {
                console.log("üîó Conex√£o de dados recebida");
                dataConn = conn;

                conn.on('open', () => {
                    console.log("‚úÖ Canal de dados aberto");
                    if (window.deltaUI) deltaUI.showNotification("HQ CONNECTED", "success");
                    broadcastTelemetry();
                });

                conn.on('data', (data) => {
                    if (window.deltaChat) window.deltaChat.receive(data);
                });
            });

            peer.on('call', async (call) => {
                console.log("üìû Recebendo chamada de video...");
                if (window.deltaUI) deltaUI.showNotification("INCOMING VIDEO CALL...", "warning");

                let streamToUse = window.rawCameraStream;

                // Fallback if camera stream is missing
                if (!streamToUse || streamToUse.getVideoTracks().length === 0) {
                    console.warn("‚ö†Ô∏è Stream de c√¢mera inv√°lido ou sem v√≠deo. Tentando readquirir...");
                    try {
                        streamToUse = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: true });
                        window.rawCameraStream = streamToUse; // Update global
                    } catch (e) {
                        console.error("‚ùå Falha ao adquirir c√¢mera para chamada:", e);
                        // Answer with audio only if video fails
                        try {
                            streamToUse = await navigator.mediaDevices.getUserMedia({ audio: true });
                        } catch (e2) {
                            console.error("‚ùå Falha total de media:", e2);
                            // Create dummy stream to keep connection alive
                            const ctx = new AudioContext();
                            const dst = ctx.createMediaStreamDestination();
                            streamToUse = dst.stream;
                        }
                    }
                }

                const answerStream = new MediaStream();
                streamToUse.getTracks().forEach(track => answerStream.addTrack(track));

                console.log("üì§ Respondendo chamada com tracks:", answerStream.getTracks().map(t => t.kind));
                call.answer(answerStream);

                call.on('close', () => {
                    console.log("Call closed");
                    if (window.deltaUI) deltaUI.showNotification("CALL ENDED", "info");
                });

                call.on('error', (e) => {
                    console.error("Call error:", e);
                    if (window.deltaUI) deltaUI.showNotification("CALL ERROR", "error");
                });
            });
        }

        async function getCameraStream() {
            console.log('üìπ Tentando acessar c√¢mera...');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' },
                    audio: true
                });
                console.log('‚úÖ C√¢mera traseira ativada');
                return stream;
            } catch (e) {
                console.log('‚ö†Ô∏è Tentativa 1 falhou, tentando qualquer c√¢mera...');
                try {
                    return await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                } catch (err) {
                    console.log('‚ùå Falha fatal na c√¢mera:', err);
                    return null;
                }
            }
        }

        async function engageSystems() {
            startBtn.innerText = "ACCESSING CAM...";
            errorMsg.style.display = "none";
            try {
                rawCameraStream = await getCameraStream();
                if (!rawCameraStream) throw new Error("No video stream available");
                window.rawCameraStream = rawCameraStream;

                video.srcObject = rawCameraStream;
                await video.play();
                console.log('‚ñ∂Ô∏è V√≠deo iniciado');

                document.getElementById('loading').style.display = 'none';

                resizeCanvas();
                const canvasStream = canvas.captureStream(30);
                localStream = new MediaStream();
                canvasStream.getVideoTracks().forEach(t => localStream.addTrack(t));
                rawCameraStream.getAudioTracks().forEach(t => localStream.addTrack(t));

                initNetworkID();
                initGPS();
                requestAnimationFrame(renderLoop);
                aiLoop();
            } catch (e) {
                console.error('‚ùå Erro ao ativar c√¢mera:', e);
                document.getElementById('error-msg').innerText = e.message + ". Check permissions.";
                document.getElementById('error-msg').style.display = 'block';
                startBtn.innerText = "RETRY";
            }
        }

        window.onload = bootSequence;
    </script>

    <!-- DELTA FEATURES EMBEDDED -->
    <script>
        // DELTA RECON - MODULO DE FUNCIONALIDADES AVANCADAS (EMBUTIDO)
        console.log('Delta Features Module carregado (EMBUTIDO)');

        // 1. CAPTURA DE FOTO
        window.deltaPhoto = {
            capture: function () {
                const canvas = document.createElement('canvas');
                const video = document.getElementById('video');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                canvas.getContext('2d').drawImage(video, 0, 0);

                const photo = canvas.toDataURL('image/jpeg', 0.9);
                const timestamp = new Date().toISOString();

                // Salvar localmente
                const link = document.createElement('a');
                link.download = `DELTA_${Date.now()}.jpg`;
                link.href = photo;
                link.click();

                // Enviar para comando
                if (window.dataConn && window.dataConn.open) {
                    window.dataConn.send({
                        type: 'PHOTO_CAPTURE',
                        payload: {
                            image: photo,
                            timestamp: timestamp,
                            gps: window.currentGPS || { lat: 0, lon: 0 },
                            threat: window.currentThreatStatus || 'UNKNOWN'
                        }
                    });
                }

                // Feedback visual
                deltaUI.showNotification('FOTO CAPTURADA', 'success');
                deltaAudio.play('camera_shutter');
                console.log('Foto capturada:', timestamp);
                return photo;
            }
        };

        // 2. CHAT DE TEXTO
        window.deltaChat = {
            messages: [],
            init: function () {
                if (!document.getElementById('chat-panel')) {
                    const chatPanel = document.createElement('div');
                    chatPanel.id = 'chat-panel';
                    chatPanel.className = 'hidden absolute bottom-20 left-2 right-2 bg-black/90 border border-green-500 p-2 z-40 h-48 flex flex-col';
                    chatPanel.innerHTML = `
                        <div id="chat-history" class="flex-1 overflow-y-auto text-[10px] font-mono mb-2 space-y-1"></div>
                        <div class="flex gap-1">
                            <input type="text" id="chat-input" class="flex-1 bg-green-900/20 border border-green-700 text-green-400 text-xs p-1 focus:outline-none" placeholder="MSG...">
                            <button onclick="deltaChat.send()" class="bg-green-600 text-black text-xs px-3 font-bold">SEND</button>
                        </div>
                        <div class="flex gap-1 mt-1 overflow-x-auto">
                            <button onclick="deltaChat.send('CONTACT FRONT')" class="bg-green-900/40 border border-green-700 text-[9px] px-2 py-1 text-green-500 whitespace-nowrap">CONTACT</button>
                            <button onclick="deltaChat.send('NEED BACKUP')" class="bg-green-900/40 border border-green-700 text-[9px] px-2 py-1 text-green-500 whitespace-nowrap">BACKUP</button>
                            <button onclick="deltaChat.send('MOVING')" class="bg-green-900/40 border border-green-700 text-[9px] px-2 py-1 text-green-500 whitespace-nowrap">MOVING</button>
                            <button onclick="deltaChat.send('HOLDING')" class="bg-green-900/40 border border-green-700 text-[9px] px-2 py-1 text-green-500 whitespace-nowrap">HOLDING</button>
                        </div>
                    `;
                    document.getElementById('ui-layer').appendChild(chatPanel);
                    document.getElementById('chat-input').addEventListener('keypress', function (e) {
                        if (e.key === 'Enter') deltaChat.send();
                    });
                }
            },
            toggle: function () {
                const panel = document.getElementById('chat-panel');
                if (panel) {
                    panel.classList.toggle('hidden');
                    if (!panel.classList.contains('hidden')) {
                        document.getElementById('chat-input').focus();
                    }
                }
            },
            send: function (text = null) {
                const input = document.getElementById('chat-input');
                const msg = text || input.value;
                if (!msg) return;
                this.display('ME', msg, 'text-green-400');
                if (window.dataConn && window.dataConn.open) {
                    window.dataConn.send({
                        type: 'CHAT_MESSAGE',
                        payload: {
                            sender: window.myPeerId || 'SOLDIER',
                            text: msg,
                            timestamp: new Date().toISOString()
                        }
                    });
                }
                if (!text) input.value = '';
                deltaAudio.play('message_sent');
            },
            receive: function (sender, text) {
                this.display(sender, text, 'text-yellow-400');
                deltaUI.showNotification(`MSG: ${sender}`, 'info');
                deltaAudio.play('message_received');
                const panel = document.getElementById('chat-panel');
                if (panel && panel.classList.contains('hidden')) {
                    panel.classList.remove('hidden');
                }
            },
            display: function (sender, text, colorClass) {
                const history = document.getElementById('chat-history');
                if (!history) return;
                const line = document.createElement('div');
                const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                line.innerHTML = `<span class="text-gray-500">[${time}]</span> <span class="font-bold ${colorClass}">${sender}:</span> <span class="text-white">${text}</span>`;
                history.appendChild(line);
                history.scrollTop = history.scrollHeight;
            }
        };

        // 3. ALERTAS SONOROS
        window.deltaAudio = {
            ctx: null,
            init: function () {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                } catch (e) { console.log('Web Audio API nao suportada'); }
            },
            play: function (type, count = 1) {
                if (!this.ctx) this.init();
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                const now = this.ctx.currentTime;
                if (type === 'camera_shutter') {
                    osc.type = 'square'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                } else if (type === 'message_received') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.setValueAtTime(1800, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                } else if (type === 'message_sent') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); osc.frequency.setValueAtTime(1200, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                }
            }
        };

        // 4. GRAVACAO DE VIDEO
        window.deltaRecording = {
            mediaRecorder: null,
            chunks: [],
            isRecording: false,
            start: function () {
                const stream = document.getElementById('outputCanvas').captureStream(30);
                this.chunks = [];
                this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                this.mediaRecorder.ondataavailable = e => this.chunks.push(e.data);
                this.mediaRecorder.onstop = e => {
                    const blob = new Blob(this.chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `MISSION_REC_${Date.now()}.webm`;
                    a.click();
                    deltaUI.showNotification('GRAVACAO SALVA', 'success');
                };
                this.mediaRecorder.start();
                this.isRecording = true;
                deltaUI.showNotification('GRAVANDO...', 'warning');
                const btn = document.getElementById('btn-rec');
                if (btn) { btn.innerText = 'STOP REC'; btn.classList.add('bg-red-600', 'text-white'); }
            },
            stop: function () {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    const btn = document.getElementById('btn-rec');
                    if (btn) { btn.innerText = 'START REC'; btn.classList.remove('bg-red-600', 'text-white'); }
                }
            }
        };

        // 5. UI HELPER
        window.deltaUI = {
            showNotification: function (text, type = 'info') {
                const container = document.getElementById('notification-container') || this.createContainer();
                const notif = document.createElement('div');
                let color = 'text-green-400 border-green-500';
                if (type === 'warning') color = 'text-orange-400 border-orange-500';
                if (type === 'error') color = 'text-red-400 border-red-500';
                if (type === 'success') color = 'text-cyan-400 border-cyan-500';
                notif.className = `bg-black/80 border ${color} px-4 py-2 mb-2 text-xs font-bold tracking-wider animate-pulse`;
                notif.innerText = text;
                container.appendChild(notif);
                setTimeout(() => notif.remove(), 3000);
            },
            createContainer: function () {
                const div = document.createElement('div'); div.id = 'notification-container';
                div.className = 'absolute top-20 left-1/2 -translate-x-1/2 z-50 flex flex-col items-center pointer-events-none';
                document.body.appendChild(div);
                return div;
            },
            injectControls: function () {
                const controls = document.querySelector('.controls');
                if (!controls) return;
                const row = document.createElement('div');
                row.className = 'flex justify-between items-center gap-2 mt-2';

                const btnPhoto = document.createElement('button');
                btnPhoto.className = 'w-1/3 border border-green-500 bg-green-900/40 text-[10px] py-2 text-green-300 font-bold hover:bg-green-500 hover:text-black transition-all';
                btnPhoto.innerText = 'CAPTURE PHOTO';
                btnPhoto.onclick = () => deltaPhoto.capture();

                const btnRec = document.createElement('button');
                btnRec.id = 'btn-rec';
                btnRec.className = 'w-1/3 border border-green-500 bg-green-900/40 text-[10px] py-2 text-green-300 font-bold hover:bg-green-500 hover:text-black transition-all';
                btnRec.innerText = 'START REC';
                btnRec.onclick = () => { if (deltaRecording.isRecording) deltaRecording.stop(); else deltaRecording.start(); };

                const btnChat = document.createElement('button');
                btnChat.className = 'w-1/3 border border-green-500 bg-green-900/40 text-[10px] py-2 text-green-300 font-bold hover:bg-green-500 hover:text-black transition-all';
                btnChat.innerText = 'TOGGLE CHAT';
                btnChat.onclick = () => deltaChat.toggle();

                row.appendChild(btnPhoto); row.appendChild(btnRec); row.appendChild(btnChat);
                controls.appendChild(row);
                deltaChat.init();
            }
        };

        // Auto-inicializacao
        window.addEventListener('load', () => {
            setTimeout(() => {
                deltaUI.injectControls();
                console.log('Delta Controls Injected');
            }, 2000);
        });
    </script>
</body>

</html>
